{"version":3,"file":"demo.bundle.js","mappings":"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","sources":["webpack:///./lib/quadgrid.type.ts","webpack:///./demo.ts","webpack:///./lib/quadgrid.ts"],"sourcesContent":["export interface iQuadGrid {\r\n    cellItemsMax?: number,\r\n    cellDepthMax?: number,\r\n    cellMinSize?: number,\r\n\r\n    nodeBounds: bBound,\r\n    nodesInfo: bNodeInfo,\r\n    nodesRef: bNode,\r\n}\r\n\r\n\r\nexport interface iQuadNode {\r\n    bound: iBound,      // bound of this node\r\n    level: number,      // this node's level\r\n    nodes: iQuadNode[], // 4 child nodes\r\n    rects?: iBound[],  // iBound , only quadTree need it, quadGrid dont need\r\n    covered?: boolean,   // node is totally inside a bound area\r\n    taken?: boolean,     // node has at least one bound object\r\n}\r\n\r\n\r\nexport type iBound = number[];  // x, y, width, height,\r\n\r\n// 0 to 65535\r\nexport type bBound = Int16Array;    // [mx, my, hw, hh]\r\nexport type bNode = Int32Array;      // [ltId, rtId, rbId, lbId]\r\nexport type bNodeInfo = Int8Array;     // [level, covered, taken]\r\n\r\nexport const epNodeInfo = {\r\n    level: 0,\r\n    covered: 1,\r\n    taken: 2,\r\n}","import {QuadGrid} from \"./lib/quadgrid\";\r\nimport {epNodeInfo, iBound} from \"./lib/quadgrid.type\";\r\n\r\nconst width = 1200, height = 1000;\r\nconst min = 2, max = 10;\r\n\r\nlet maxDepth = 0;\r\nlet boundSize = Math.min(width, height);\r\nwhile (boundSize > min) {\r\n    boundSize /= 2;\r\n    maxDepth++;\r\n}\r\n\r\nconst grid = new QuadGrid(width, height, maxDepth);\r\n\r\n/*\r\n* states\r\n* */\r\nconst states = {\r\n    rects: [] as iBound[],\r\n}\r\n\r\n/*\r\n* init UI\r\n* */\r\nconst canvas = document.getElementById(\"canvas\")\r\ncanvas.setAttribute(\"width\", width + \"\");\r\ncanvas.setAttribute(\"height\", height + \"\");\r\ncanvas.style.background = \"#111\";\r\nconst ctx = (canvas as HTMLCanvasElement).getContext('2d');\r\n\r\n\r\n/*\r\n* mouse event\r\n* */\r\n\r\n\r\n/*\r\n* main\r\n* */\r\n\r\n(function render() {\r\n    _updateUI();\r\n    window.requestAnimationFrame(render);\r\n})()\r\n\r\n\r\n/*\r\n* quadtree util\r\n* */\r\nfunction _random(min, max) {\r\n    return Math.round(min + (Math.random() * (max - min)));\r\n}\r\n\r\n(window as any).addNodes = function (amount: number, large = false) {\r\n    const arrSize = Math.ceil(Math.sqrt(amount));\r\n    const arr = Array(arrSize).fill(null);\r\n    arr.forEach((ignore, r) => {\r\n        arr.forEach((ignore, c) => {\r\n            // const w = _random(min, max) * (large ? 30 : 1) / 2;\r\n            // const h = _random(min, max) * (large ? 30 : 1) / 2;\r\n            const w = _random(min, max) * (large || (amount >= 10 && r < arrSize * 0.2) ? 20 : 1) / 2;\r\n            const h = _random(min, max) * (large || (amount >= 10 && c < arrSize * 0.2) ? 20 : 1) / 2;\r\n            states.rects.push([\r\n                _random(w, width - w),\r\n                _random(h, height - h),\r\n                w,\r\n                h,\r\n            ] as iBound)\r\n\r\n            // const w  =min * (large || (amount >= 10 && r < amount * 0.1) ? 30 : 1) / 2;\r\n            // const h = min * (large || (amount >= 10 && c < amount * 0.1) ? 30 : 1) / 2;\r\n            // states.rects.push( [\r\n            //     w * 3 * r * 1.1 + w,\r\n            //     h * 3 * c * 1.1 + h,\r\n            //     w,\r\n            //     h,\r\n            // ] as iBound)\r\n        })\r\n\r\n    })\r\n\r\n    const start = performance.now();\r\n    for (let i = 0; i < states.rects.length; i++) {\r\n        grid.insert(0, states.rects[i])\r\n    }\r\n    const startUi = performance.now();\r\n    console.log(`add ${amount} duration`, startUi - start)\r\n    console.log(`allNodes`, grid.nodeAnchor);\r\n}\r\n\r\n\r\n/*\r\n* render util\r\n* */\r\nfunction _updateUI() {\r\n    if (grid.nodeAnchor === 1) return;\r\n    ctx.clearRect(0, 0, width, height);\r\n\r\n    document.getElementById(\"info_count\").innerText = states.rects.length + \"\";\r\n\r\n    // draw grid\r\n    _drawGridNodes();\r\n    _drawGridTaken();\r\n    _drawGridTakenStroke();\r\n}\r\n\r\nfunction _drawGridNodes(nodeIndex?: number) {\r\n    if (nodeIndex === 0) return;\r\n    const boundOffset = (nodeIndex || 0) * 4;\r\n    if (grid.nodesRef[boundOffset]) {\r\n        for (let i = 0; i < 4; i++) {\r\n            _drawGridNodes(grid.nodesRef[boundOffset + i])\r\n        }\r\n    } else {\r\n        const infoOffset = nodeIndex * grid.nodesInfoSize;\r\n        if (!grid.nodesInfo[infoOffset + epNodeInfo.taken]) {\r\n            ctx.strokeStyle = \"rgba(0, 255, 0, 0.4)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(grid.nodeBounds.subarray(boundOffset, boundOffset + 4)))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _drawGridTaken(nodeIndex?: number) {\r\n    if (nodeIndex === 0) return;\r\n    const boundOffset = (nodeIndex || 0) * 4;\r\n    if (grid.nodesRef[boundOffset]) {\r\n        for (let i = 0; i < 4; i++) {\r\n            _drawGridTaken(grid.nodesRef[boundOffset + i])\r\n        }\r\n    } else {\r\n        const infoOffset = nodeIndex * grid.nodesInfoSize;\r\n        if (grid.nodesInfo[infoOffset + epNodeInfo.taken]) {\r\n            ctx.fillStyle = \"rgba(6, 6, 6, 0.8)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(grid.nodeBounds.subarray(boundOffset, boundOffset + 4)))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _drawGridTakenStroke(nodeIndex?: number) {\r\n    if (nodeIndex === 0) return;\r\n    const boundOffset = (nodeIndex || 0) * 4;\r\n    if (grid.nodesRef[boundOffset]) {\r\n        for (let i = 0; i < 4; i++) {\r\n            _drawGridTakenStroke(grid.nodesRef[boundOffset + i])\r\n        }\r\n    } else {\r\n        const infoOffset = nodeIndex * grid.nodesInfoSize;\r\n        if (grid.nodesInfo[infoOffset + epNodeInfo.taken]) {\r\n            ctx.strokeStyle = \"rgba(152,11,11,0.8)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(grid.nodeBounds.subarray(boundOffset, boundOffset + 4)))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _getBound(bound: iBound) {\r\n    return [bound[0] - bound[2], bound[1] - bound[3], bound[2] * 2, bound[3] * 2];\r\n}","import {epNodeInfo, iBound, iQuadGrid, iQuadNode} from \"./quadgrid.type\";\r\n\r\nexport function QuadNode(bound: iBound, level: number): iQuadNode {\r\n    return {\r\n        bound,\r\n        level,\r\n        nodes: [],\r\n    }\r\n}\r\n\r\nexport class QuadGrid implements iQuadGrid {\r\n    cellMinSize: number;\r\n    cellBatchSize = 100000;\r\n\r\n    nodeBounds: Int16Array;\r\n    nodesInfo: Int8Array;\r\n    nodesInfoSize = Object.keys(epNodeInfo).length;  // [level, covered, taken]\r\n    nodesRef: Int32Array;\r\n\r\n    nodeAnchor = 0;\r\n\r\n    constructor(public width, public height,\r\n                public cellDepthMax = 6) {\r\n        this.cellMinSize = Math.min(width, height) / Math.pow(2, cellDepthMax);\r\n\r\n        this.nodeBounds = new Int16Array(this.cellBatchSize * 4);\r\n        this.nodesRef = new Int32Array(this.cellBatchSize * 4);\r\n        this.nodesInfo = new Int8Array(this.cellBatchSize * this.nodesInfoSize);\r\n\r\n        this.newNode(width / 2, height / 2, width / 2, height / 2, 0);\r\n    }\r\n\r\n    newNode(mx: number, my: number, hw: number, hh: number, level: number) {\r\n        this.nodeBounds.set([mx, my, hw, hh], this.nodeAnchor * 4);\r\n        this.nodesInfo[this.nodeAnchor * 3] = level;\r\n        const nodeIndex = this.nodeAnchor;\r\n        this.nodeAnchor++;\r\n        return nodeIndex;\r\n    }\r\n\r\n\r\n    split(nodeIndex: number) {\r\n        const boundOffset = nodeIndex * 4;\r\n        const nextLevel = this.nodesInfo[nodeIndex * this.nodesInfoSize + epNodeInfo.level] + 1,\r\n            x = this.nodeBounds[boundOffset],\r\n            y = this.nodeBounds[boundOffset + 1],\r\n            subWidth = this.nodeBounds[boundOffset + 2] / 2,\r\n            subHeight = this.nodeBounds[boundOffset + 3] / 2;\r\n\r\n        this.nodesRef.set([\r\n            this.newNode(x - subWidth, y - subHeight, subWidth, subHeight, nextLevel), //lt\r\n            this.newNode(x + subWidth, y - subHeight, subWidth, subHeight, nextLevel), //rt\r\n            this.newNode(x + subWidth, y + subHeight, subWidth, subHeight, nextLevel), //rb\r\n            this.newNode(x - subWidth, y + subHeight, subWidth, subHeight, nextLevel), //lb\r\n        ], boundOffset);\r\n    }\r\n\r\n    getIndex(boundOffset: number, rect: iBound) {\r\n        let indexes = 0b0,\r\n            verticalMidpoint = this.nodeBounds[boundOffset],\r\n            horizontalMidpoint = this.nodeBounds[boundOffset + 1];\r\n\r\n        const startIsNorth = rect[1] - rect[3] < horizontalMidpoint,\r\n            startIsWest = rect[0] - rect[2] < verticalMidpoint,\r\n            endIsEast = rect[0] + rect[2] > verticalMidpoint,\r\n            endIsSouth = rect[1] + rect[3] > horizontalMidpoint;\r\n\r\n        //lt\r\n        if (startIsWest && startIsNorth) {\r\n            indexes = indexes | 0b1;\r\n        }\r\n\r\n        //rt\r\n        if (startIsNorth && endIsEast) {\r\n            indexes = indexes | 0b10;\r\n        }\r\n\r\n        //rb\r\n        if (endIsEast && endIsSouth) {\r\n            indexes = indexes | 0b100;\r\n        }\r\n\r\n        //lb\r\n        if (startIsWest && endIsSouth) {\r\n            indexes = indexes | 0b1000;\r\n        }\r\n\r\n        return indexes;\r\n    }\r\n\r\n    merge(boundOffset: number) {\r\n        this.nodesRef.set([0, 0, 0, 0], boundOffset);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number} offset   nodeBounds index offset\r\n     * @param {iBound} rect\r\n     * @returns {boolean}\r\n     */\r\n    inside(offset: number, rect: iBound) {\r\n        return this.nodeBounds[offset] - this.nodeBounds[offset + 2] > rect[0] - rect[2] && this.nodeBounds[offset + 1] - this.nodeBounds[offset + 3] > rect[1] - rect[3] &&\r\n            this.nodeBounds[offset] + this.nodeBounds[offset + 2] < rect[0] + rect[2] &&\r\n            this.nodeBounds[offset + 1] + this.nodeBounds[offset + 3] < rect[1] + rect[3];\r\n    }\r\n\r\n    insertBatch(boundOffset: number, rect: iBound, method: string) {\r\n        const binaryIndexes = this.getIndex(boundOffset, rect);\r\n        binaryIndexes & 0b1 && this[method](this.nodesRef[boundOffset], rect);\r\n        binaryIndexes & 0b10 && this[method](this.nodesRef[boundOffset + 1], rect);\r\n        binaryIndexes & 0b100 && this[method](this.nodesRef[boundOffset + 2], rect);\r\n        binaryIndexes & 0b1000 && this[method](this.nodesRef[boundOffset + 3], rect);\r\n    }\r\n\r\n    insert(nodeIndex: number, rect: iBound) {\r\n        const boundOffset = nodeIndex * 4;\r\n        const infoOffset = nodeIndex * this.nodesInfoSize;\r\n        const newCoverTest = this.inside(boundOffset, rect);\r\n        if (newCoverTest === true) {\r\n            if (this.nodesInfo[infoOffset + epNodeInfo.covered] !== 1) {\r\n                this.merge(boundOffset);\r\n                this.nodesInfo[infoOffset + epNodeInfo.taken] = 1;\r\n                this.nodesInfo[infoOffset + epNodeInfo.covered] = 1;\r\n            }\r\n        } else {\r\n            if (this.nodesInfo[infoOffset + epNodeInfo.level] < this.cellDepthMax && !this.nodesInfo[infoOffset + epNodeInfo.covered] && !this.nodesRef[boundOffset]) {\r\n                this.split(nodeIndex);\r\n            }\r\n\r\n            if (this.nodesRef[boundOffset]) {\r\n                this.insertBatch(boundOffset, rect, \"insert\");\r\n            }\r\n\r\n            if (this.nodesRef[boundOffset] === 0) {\r\n                this.nodesInfo[infoOffset + epNodeInfo.taken] = 1;\r\n            } else {\r\n                this.nodesInfo[infoOffset + epNodeInfo.taken] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    allNodes(nodeStore: iQuadNode[], node: iQuadNode): iQuadNode[] {\r\n        if (node.nodes.length > 0) {\r\n            node.nodes.forEach(n => {\r\n                this.allNodes(nodeStore, n);\r\n            })\r\n        } else {\r\n            nodeStore.push(node);\r\n        }\r\n        return nodeStore;\r\n    }\r\n}\r\n"],"names":["epNodeInfo","level","covered","taken","width","height","maxDepth","boundSize","Math","min","grid","constructor","cellDepthMax","cellBatchSize","nodesInfoSize","Object","keys","length","nodeAnchor","this","cellMinSize","pow","nodeBounds","Int16Array","nodesRef","Int32Array","nodesInfo","Int8Array","newNode","mx","my","hw","hh","set","nodeIndex","split","boundOffset","nextLevel","x","y","subWidth","subHeight","getIndex","rect","indexes","verticalMidpoint","horizontalMidpoint","startIsNorth","startIsWest","endIsEast","endIsSouth","merge","inside","offset","insertBatch","method","binaryIndexes","insert","infoOffset","allNodes","nodeStore","node","nodes","forEach","n","push","states","rects","canvas","document","getElementById","setAttribute","style","background","ctx","getContext","_random","max","round","random","_drawGridNodes","i","strokeStyle","strokeRect","_getBound","subarray","_drawGridTaken","fillStyle","_drawGridTakenStroke","bound","render","clearRect","innerText","window","requestAnimationFrame","addNodes","amount","large","arrSize","ceil","sqrt","arr","Array","fill","ignore","r","c","w","h","start","performance","now","startUi","console","log"],"sourceRoot":""}