{"version":3,"file":"demo.bundle.js","mappings":"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","sources":["webpack:///./lib/quadgrid.ts","webpack:///./demo.ts"],"sourcesContent":["import {iBound, iQuadGrid, iQuadNode} from \"./quadgrid.type\";\r\n\r\nexport function QuadNode(bound: iBound, level: number): iQuadNode {\r\n    return {\r\n        bound,\r\n        level,\r\n        nodes: [],\r\n        rects: [],\r\n    }\r\n}\r\n\r\nexport class QuadGrid implements iQuadGrid {\r\n    root: iQuadNode;\r\n    cellMinSize: number;\r\n\r\n    constructor(public width, public height,\r\n                public cellDepthMax = 6, public cellItemsMax = 10) {\r\n        this.cellMinSize = Math.min(width, height) / Math.pow(2, cellDepthMax);\r\n        this.root = QuadNode([width / 2, height / 2, width / 2, height / 2], 0);\r\n    }\r\n\r\n    split(node: iQuadNode) {\r\n        const nextLevel = node.level + 1,\r\n            x = node.bound[0],\r\n            y = node.bound[1],\r\n            subWidth = node.bound[2] / 2,\r\n            subHeight = node.bound[3] / 2;\r\n\r\n        //lt\r\n        node.nodes[0] = QuadNode([\r\n            x - subWidth,\r\n            y - subHeight,\r\n            subWidth,\r\n            subHeight\r\n        ], nextLevel);\r\n\r\n        //rt\r\n        node.nodes[1] = QuadNode([\r\n            x + subWidth,\r\n            y - subHeight,\r\n            subWidth,\r\n            subHeight\r\n        ], nextLevel);\r\n\r\n        //rb\r\n        node.nodes[2] = QuadNode([\r\n            x + subWidth,\r\n            y + subHeight,\r\n            subWidth,\r\n            subHeight\r\n        ], nextLevel);\r\n\r\n        //lb\r\n        node.nodes[3] = QuadNode([\r\n            x - subWidth,\r\n            y + subHeight,\r\n            subWidth,\r\n            subHeight\r\n        ], nextLevel);\r\n    }\r\n\r\n    getIndex(node: iQuadNode, rect: iBound) {\r\n        let indexes = 0b0,\r\n            verticalMidpoint = node.bound[0] ,\r\n            horizontalMidpoint = node.bound[1];\r\n\r\n        const startIsNorth = rect[1] - rect[3] < horizontalMidpoint,\r\n            startIsWest = rect[0] - rect[2] < verticalMidpoint,\r\n            endIsEast = rect[0] + rect[2] > verticalMidpoint,\r\n            endIsSouth = rect[1] + rect[3] > horizontalMidpoint;\r\n\r\n        //lt\r\n        if (startIsWest && startIsNorth) {\r\n            indexes = indexes | 0b1;\r\n        }\r\n\r\n        //rt\r\n        if (startIsNorth && endIsEast) {\r\n            indexes = indexes | 0b10;\r\n        }\r\n\r\n        //rb\r\n        if (endIsEast && endIsSouth) {\r\n            indexes = indexes | 0b100;\r\n        }\r\n\r\n        //lb\r\n        if (startIsWest && endIsSouth) {\r\n            indexes = indexes | 0b1000;\r\n        }\r\n\r\n        return indexes;\r\n    }\r\n\r\n    merge(node: iQuadNode) {\r\n        node.rects.push(...this.allRects([], node));\r\n        node.nodes.splice(0);\r\n    }\r\n\r\n    inside(bound: iBound, rect: iBound) {\r\n        return bound[0] - bound[2] > rect[0] - rect[2] && bound[1] - bound[3] > rect[1] - rect[3] &&\r\n            bound[0] + bound[2] < rect[0] + rect[2] &&\r\n            bound[1] + bound[3] < rect[1] + rect[3];\r\n    }\r\n\r\n    insertBatch(node: iQuadNode, rect: iBound, method: string) {\r\n        const binaryIndexes = this.getIndex(node, rect);\r\n        binaryIndexes & 0b1 && this[method](node.nodes[0], rect);\r\n        binaryIndexes & 0b10 && this[method](node.nodes[1], rect);\r\n        binaryIndexes & 0b100 && this[method](node.nodes[2], rect);\r\n        binaryIndexes & 0b1000 && this[method](node.nodes[3], rect);\r\n    }\r\n\r\n    _times = [];\r\n    _timesCovered = [];\r\n\r\n    insertAsGrid(node: iQuadNode, rect: iBound) {\r\n        const newCoverTest = this.inside(node.bound, rect);\r\n        if (newCoverTest === true) {\r\n            if (node.covered !== true) {\r\n                this.merge(node);\r\n                node.taken = true;\r\n                node.covered = true;\r\n            }\r\n            node.rects.push(rect);\r\n            this._timesCovered.push(performance.now(), node.bound, node.level);\r\n        } else {\r\n            node.rects.push(rect);\r\n            if (node.nodes.length) {\r\n                this.insertBatch(node, rect, \"insertAsGrid\");\r\n                node.rects.splice(0);\r\n            } else if (node.covered !== true) {\r\n                if (node.level < this.cellDepthMax) {\r\n                    this.split(node);\r\n                    node.rects.forEach(rect => {\r\n                        this.insertBatch(node, rect, \"insertAsGrid\");\r\n                    })\r\n\r\n                    node.rects.splice(0);\r\n                }\r\n            }\r\n\r\n            if (node.nodes.length === 0 && node.rects.length > 0) {\r\n                node.taken = true;\r\n            } else {\r\n                delete node.taken;\r\n            }\r\n            this._times.push(performance.now(), node.bound, node.level);\r\n        }\r\n    }\r\n\r\n    insertAsTree(node: iQuadNode, rect: iBound) {\r\n\r\n        if (node.nodes.length) {\r\n            this.insertBatch(node, rect, \"insertAsTree\");\r\n            return;\r\n        }\r\n\r\n        node.rects.push(rect);\r\n        if (node.rects.length > this.cellItemsMax && node.level < this.cellDepthMax) {\r\n            if (!node.nodes.length) {\r\n                this.split(node);\r\n            }\r\n\r\n            node.rects.forEach(rect =>\r\n                this.insertBatch(node, rect, \"insertAsTree\")\r\n            )\r\n\r\n            node.rects.splice(0);\r\n        }\r\n    }\r\n\r\n    allNodes(nodeStore: iQuadNode[], node: iQuadNode): iQuadNode[] {\r\n        if (node.nodes.length > 0) {\r\n            node.nodes.forEach(n => {\r\n                this.allNodes(nodeStore, n);\r\n            })\r\n        } else {\r\n            nodeStore.push(node);\r\n        }\r\n        return nodeStore;\r\n    }\r\n\r\n    allRects(rectStore: iBound[], node: iQuadNode): iBound[] {\r\n        if (node.nodes.length > 0) {\r\n            node.nodes.forEach(n => {\r\n                this.allRects(rectStore, n);\r\n            })\r\n        } else {\r\n            rectStore.push(...node.rects);\r\n        }\r\n        return rectStore;\r\n    }\r\n\r\n    retrieve(node: iQuadNode, bound: iBound, rectStore?: iBound[]): Set<iBound> {\r\n        const indexes = this.getIndex(node, bound);\r\n        const store = rectStore || [];\r\n\r\n        if (node.nodes.length) {\r\n            indexes & 0b1 && this.retrieve(node.nodes[0], bound, store);\r\n            indexes & 0b10 && this.retrieve(node.nodes[1], bound, store);\r\n            indexes & 0b100 && this.retrieve(node.nodes[2], bound, store);\r\n            indexes & 0b1000 && this.retrieve(node.nodes[3], bound, store);\r\n        }\r\n\r\n        if (rectStore) {\r\n            node.nodes.length === 0 && rectStore.push(...node.rects);\r\n        } else {\r\n            return new Set(store);\r\n        }\r\n    }\r\n\r\n    clear() {\r\n        this.root.nodes.splice(0);\r\n        this.root.rects.splice(0);\r\n        delete this.root.taken;\r\n        delete this.root.covered;\r\n    }\r\n}\r\n","import {QuadGrid} from \"./lib/quadgrid\";\r\nimport {iBound, iQuadNode} from \"./lib/quadgrid.type\";\r\n\r\nconst width = 1200, height = 1000;\r\nconst min = 2, max = 10;\r\n\r\nlet maxDepth = 0, maxItems = 2;\r\nlet boundSize = Math.min(width, height);\r\nwhile (boundSize > min) {\r\n    boundSize /= 2;\r\n    maxDepth++;\r\n}\r\n\r\nconst grid = new QuadGrid(width, height, maxDepth, maxItems);\r\nconst focus = [0, 0, 50, 50];\r\n\r\n/*\r\n* states\r\n* */\r\nconst states = {\r\n    activeRects: new Set() as Set<iBound>,\r\n    rects: [] as iBound[],\r\n}\r\n\r\n/*\r\n* init UI\r\n* */\r\nconst canvas = document.getElementById(\"canvas\")\r\ncanvas.setAttribute(\"width\", width + \"\");\r\ncanvas.setAttribute(\"height\", height + \"\");\r\ncanvas.style.background = \"#111\";\r\nconst ctx = (canvas as HTMLCanvasElement).getContext('2d');\r\n\r\n\r\n/*\r\n* mouse event\r\n* */\r\nlet mouseOn = false;\r\ncanvas.addEventListener(\"mousemove\", function (e: any) {\r\n    mouseOn = true;\r\n    if (!e.offsetX) {\r\n        e.offsetX = e.layerX - e.target.offsetLeft;\r\n        e.offsetY = e.layerY - e.target.offsetTop;\r\n    }\r\n    focus[0] = e.offsetX - (focus[2] / 2);\r\n    focus[1] = e.offsetY - (focus[3] / 2);\r\n});\r\ncanvas.addEventListener(\"mouseout\", function (e) {\r\n    mouseOn = false;\r\n});\r\n\r\n\r\n/*\r\n* main\r\n* */\r\n\r\n(function render() {\r\n    if (mouseOn) {\r\n        states.activeRects.clear();\r\n        states.activeRects = grid.retrieve(grid.root, focus);\r\n    }\r\n    _updateUI();\r\n    window.requestAnimationFrame(render);\r\n})()\r\n\r\n\r\n/*\r\n* quadtree util\r\n* */\r\nfunction _random(min, max) {\r\n    return Math.round(min + (Math.random() * (max - min)));\r\n}\r\n\r\n(window as any).addNodes = function (amount: number, large = false) {\r\n    states.rects.push(...Array(amount).fill(null).map((ignore, ind) => {\r\n        // const w = _random(min, max) * (large ? 30 : 1) / 2;\r\n        // const h = _random(min, max) * (large ? 30 : 1) / 2;\r\n        const w = _random(min, max) * (large || (amount >= 10 && ind < amount * 0.1) ? 30 : 1) / 2;\r\n        const h = _random(min, max) * (large || (amount >= 10 && ind < amount * 0.1) ? 30 : 1) / 2;\r\n        return [\r\n            _random(w, width - w),\r\n            _random(h, height - h),\r\n            w,\r\n            h,\r\n        ] as iBound\r\n    }))\r\n\r\n    const start = performance.now();\r\n    for (let i = 0; i < states.rects.length; i++) {\r\n        grid.insertAsGrid(grid.root, states.rects[i])\r\n        // grid.insertAsTree(grid.root, states.rects[i])\r\n    }\r\n    const startUi = performance.now();\r\n    console.log(`add ${amount} duration`, startUi - start)\r\n    console.log(`allNodes`, grid.allNodes([], grid.root));\r\n    console.log(`times`, grid._times.length / 3, grid._times);\r\n    console.log(`timesCovered`, grid._timesCovered.length / 3, grid._timesCovered);\r\n}\r\n\r\n\r\n/*\r\n* render util\r\n* */\r\nfunction _updateUI() {\r\n    ctx.clearRect(0, 0, width, height);\r\n\r\n    document.getElementById(\"info_count\").innerText = states.rects.length + \"\";\r\n    document.getElementById(\"info_involved\").innerText = (states.activeRects?.size || 0) + \"\";\r\n\r\n    // draw focus rect\r\n    if (mouseOn) {\r\n        ctx.fillStyle = 'rgba(255,255,255,0.5)';\r\n        // @ts-ignore\r\n        ctx.fillRect(...focus);\r\n    }\r\n\r\n    // draw grid\r\n    _drawGridNodes(grid.root);\r\n    _drawGridTaken(grid.root);\r\n    _drawGridTakenStroke(grid.root);\r\n\r\n    // draw objects\r\n    states.rects.forEach(rects => {\r\n        if (states.activeRects.has(rects)) {\r\n            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\r\n            // @ts-ignore\r\n            ctx.fillRect(..._getBound(rects));\r\n        } else {\r\n            ctx.strokeStyle = 'rgba(255, 0, 0, 1)';\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(rects))\r\n        }\r\n    })\r\n}\r\n\r\nfunction _drawGridNodes(node: iQuadNode) {\r\n    if (node.nodes.length) {\r\n        node.nodes.forEach(node => _drawGridNodes(node));\r\n    } else {\r\n        if (!node.taken) {\r\n            ctx.strokeStyle = \"rgba(0, 255, 0, 0.4)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(node.bound))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _drawGridTaken(node: iQuadNode) {\r\n    if (node.nodes.length) {\r\n        node.nodes.forEach(node => _drawGridTaken(node));\r\n    } else {\r\n        if (node.taken) {\r\n            ctx.fillStyle = \"rgba(255,255,255, 0.8)\";\r\n            // @ts-ignore\r\n            ctx.fillRect(..._getBound(node.bound))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _drawGridTakenStroke(node: iQuadNode) {\r\n    if (node.nodes.length) {\r\n        node.nodes.forEach(node => _drawGridTakenStroke(node));\r\n    } else {\r\n        if (node.taken) {\r\n            ctx.strokeStyle = \"rgba(6, 6, 6, 0.8)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(node.bound))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _getBound(bound: iBound) {\r\n    return [bound[0] - bound[2], bound[1] - bound[3], bound[2] * 2, bound[3] * 2];\r\n}"],"names":["QuadNode","bound","level","nodes","rects","width","height","maxDepth","boundSize","Math","min","grid","constructor","cellDepthMax","cellItemsMax","_times","_timesCovered","this","cellMinSize","pow","root","split","node","nextLevel","x","y","subWidth","subHeight","getIndex","rect","indexes","verticalMidpoint","horizontalMidpoint","startIsNorth","startIsWest","endIsEast","endIsSouth","merge","push","allRects","splice","inside","insertBatch","method","binaryIndexes","insertAsGrid","covered","taken","performance","now","length","forEach","insertAsTree","allNodes","nodeStore","n","rectStore","retrieve","store","Set","clear","states","activeRects","canvas","document","getElementById","setAttribute","style","background","ctx","getContext","mouseOn","_random","max","round","random","_drawGridNodes","strokeStyle","strokeRect","_getBound","_drawGridTaken","fillStyle","fillRect","_drawGridTakenStroke","addEventListener","e","offsetX","layerX","target","offsetLeft","offsetY","layerY","offsetTop","render","clearRect","innerText","size","has","window","requestAnimationFrame","addNodes","amount","large","Array","fill","map","ignore","ind","w","h","start","i","startUi","console","log"],"sourceRoot":""}