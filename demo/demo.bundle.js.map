{"version":3,"file":"demo.bundle.js","mappings":"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","sources":["webpack:///./demo.ts","webpack:///./lib/quadgrid.ts"],"sourcesContent":["import {QuadGrid} from \"./lib/quadgrid\";\r\nimport {iBound} from \"./lib/quadgrid.type\";\r\n\r\nconst width = 1200, height = 1000;\r\nconst min = 2, max = 10;\r\n\r\nlet maxDepth = 0;\r\nlet boundSize = Math.min(width, height);\r\nwhile (boundSize > min) {\r\n    boundSize /= 2;\r\n    maxDepth++;\r\n}\r\n\r\nconst grid = new QuadGrid(width, height, maxDepth);\r\n\r\n/*\r\n* states\r\n* */\r\nconst states = {\r\n    rects: [] as iBound[],\r\n}\r\n\r\n/*\r\n* init UI\r\n* */\r\nconst canvas = document.getElementById(\"canvas\")\r\ncanvas.setAttribute(\"width\", width + \"\");\r\ncanvas.setAttribute(\"height\", height + \"\");\r\ncanvas.style.background = \"#111\";\r\nconst ctx = (canvas as HTMLCanvasElement).getContext('2d');\r\n\r\n\r\n/*\r\n* mouse event\r\n* */\r\n\r\n\r\n/*\r\n* main\r\n* */\r\n\r\n(function render() {\r\n    _updateUI();\r\n    window.requestAnimationFrame(render);\r\n})()\r\n\r\n\r\n/*\r\n* quadtree util\r\n* */\r\nfunction _random(min, max) {\r\n    return Math.round(min + (Math.random() * (max - min)));\r\n}\r\n\r\n(window as any).addNodes = function (amount: number, large = false) {\r\n    const arrSize = Math.ceil(Math.sqrt(amount));\r\n    const arr = Array(arrSize).fill(null);\r\n    arr.forEach((ignore, r) => {\r\n        arr.forEach((ignore, c) => {\r\n            // // const w = _random(min, max) * (large ? 30 : 1) / 2;\r\n            // // const h = _random(min, max) * (large ? 30 : 1) / 2;\r\n            // const w = _random(min, max) * (large || (amount >= 10 && r < arrSize * 0.1) ? 20 : 1) / 2;\r\n            // const h = _random(min, max) * (large || (amount >= 10 && c < arrSize * 0.1) ? 20 : 1) / 2;\r\n            // states.rects.push([\r\n            //     _random(w, width - w),\r\n            //     _random(h, height - h),\r\n            //     w,\r\n            //     h,\r\n            // ] as iBound)\r\n\r\n            const w  =min * (large || (amount >= 10 && r < amount * 0.1) ? 30 : 1) / 2;\r\n            const h = min * (large || (amount >= 10 && c < amount * 0.1) ? 30 : 1) / 2;\r\n            states.rects.push( [\r\n                w * 3 * r * 1.1 + w,\r\n                h * 3 * c * 1.1 + h,\r\n                w,\r\n                h,\r\n            ] as iBound)\r\n        })\r\n\r\n    })\r\n\r\n    const start = performance.now();\r\n    for (let i = 0; i < states.rects.length; i++) {\r\n        grid.insert(0, states.rects[i])\r\n    }\r\n    const startUi = performance.now();\r\n    console.log(`add ${amount} duration`, startUi - start)\r\n    console.log(`allNodes`, grid.nodeAnchor);\r\n}\r\n\r\n\r\n/*\r\n* render util\r\n* */\r\nfunction _updateUI() {\r\n    if (grid.nodeAnchor === 1) return;\r\n    ctx.clearRect(0, 0, width, height);\r\n\r\n    document.getElementById(\"info_count\").innerText = states.rects.length + \"\";\r\n\r\n    // draw grid\r\n    _drawGridNodes();\r\n    _drawGridTaken();\r\n    _drawGridTakenStroke();\r\n}\r\n\r\nfunction _drawGridNodes(nodeIndex?: number) {\r\n    if (nodeIndex === 0) return;\r\n    const boundOffset = (nodeIndex || 0) * 4;\r\n    if (grid.nodesRef[boundOffset]) {\r\n        for (let i = 0; i < 4; i++) {\r\n            _drawGridNodes(grid.nodesRef[boundOffset + i])\r\n        }\r\n    } else {\r\n        if (!grid.nodesTaken[nodeIndex]) {\r\n            ctx.strokeStyle = \"rgba(0, 255, 0, 0.4)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(nodeIndex))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _drawGridTaken(nodeIndex?: number) {\r\n    if (nodeIndex === 0) return;\r\n    const boundOffset = (nodeIndex || 0) * 4;\r\n    if (grid.nodesRef[boundOffset]) {\r\n        for (let i = 0; i < 4; i++) {\r\n            _drawGridTaken(grid.nodesRef[boundOffset + i])\r\n        }\r\n    } else {\r\n        if (grid.nodesTaken[nodeIndex]) {\r\n            ctx.fillStyle = \"rgba(6, 6, 6, 0.8)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(nodeIndex))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _drawGridTakenStroke(nodeIndex?: number) {\r\n    if (nodeIndex === 0) return;\r\n    const boundOffset = (nodeIndex || 0) * 4;\r\n    if (grid.nodesRef[boundOffset]) {\r\n        for (let i = 0; i < 4; i++) {\r\n            _drawGridTakenStroke(grid.nodesRef[boundOffset + i])\r\n        }\r\n    } else {\r\n        if (grid.nodesTaken[nodeIndex]) {\r\n            ctx.strokeStyle = \"rgba(152,11,11,0.8)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(nodeIndex))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _getBound(nodeIndex) {\r\n    const {nodeX, nodeY, nodeW, nodeH} = grid;\r\n    const x = nodeX[nodeIndex];\r\n    const y = nodeY[nodeIndex];\r\n    const w = nodeW[nodeIndex];\r\n    const h = nodeH[nodeIndex];\r\n    return [x - w, y - h, w * 2, h * 2];\r\n}","import {iBound, iQuadGrid} from \"./quadgrid.type\";\r\n\r\nexport class QuadGrid implements iQuadGrid {\r\n    cellMinSize: number;\r\n    cellBatchSize = 100000;\r\n\r\n    nodeX: Float32Array;\r\n    nodeY: Float32Array;\r\n    nodeW: Float32Array;\r\n    nodeH: Float32Array;\r\n    nodesRef: Int32Array;\r\n\r\n    nodesLevel: Int8Array;\r\n    nodesCovered: Int8Array;\r\n    nodesTaken: Int8Array;\r\n\r\n    nodeAnchor = 0;\r\n\r\n    constructor(public width, public height,\r\n                public cellDepthMax = 6) {\r\n        this.cellMinSize = Math.min(width, height) / Math.pow(2, cellDepthMax);\r\n\r\n        this.nodeX = new Float32Array(this.cellBatchSize);\r\n        this.nodeY = new Float32Array(this.cellBatchSize);\r\n        this.nodeW = new Float32Array(this.cellBatchSize);\r\n        this.nodeH = new Float32Array(this.cellBatchSize);\r\n        this.nodesRef = new Int32Array(this.cellBatchSize * 4);\r\n        this.nodesLevel = new Int8Array(this.cellBatchSize);\r\n        this.nodesCovered = new Int8Array(this.cellBatchSize);\r\n        this.nodesTaken = new Int8Array(this.cellBatchSize);\r\n\r\n        this.newNode(width / 2, height / 2, width / 2, height / 2, 0);\r\n    }\r\n\r\n    newNode(mx: number, my: number, hw: number, hh: number, level: number) {\r\n        this.nodeX[this.nodeAnchor] = mx;\r\n        this.nodeY[this.nodeAnchor] = my;\r\n        this.nodeW[this.nodeAnchor] = hw;\r\n        this.nodeH[this.nodeAnchor] = hh;\r\n        this.nodesLevel[this.nodeAnchor] = level;\r\n        const nodeIndex = this.nodeAnchor;\r\n        this.nodeAnchor++;\r\n        return nodeIndex;\r\n    }\r\n\r\n\r\n    split(nodeIndex: number) {\r\n        const boundOffset = nodeIndex * 4;\r\n        const nextLevel = this.nodesLevel[nodeIndex] + 1,\r\n            x = this.nodeX[nodeIndex],\r\n            y = this.nodeY[nodeIndex],\r\n            subWidth = this.nodeW[nodeIndex] / 2,\r\n            subHeight = this.nodeH[nodeIndex] / 2;\r\n\r\n        this.nodesRef.set([\r\n            this.newNode(x - subWidth, y - subHeight, subWidth, subHeight, nextLevel), //lt\r\n            this.newNode(x + subWidth, y - subHeight, subWidth, subHeight, nextLevel), //rt\r\n            this.newNode(x + subWidth, y + subHeight, subWidth, subHeight, nextLevel), //rb\r\n            this.newNode(x - subWidth, y + subHeight, subWidth, subHeight, nextLevel), //lb\r\n        ], boundOffset);\r\n    }\r\n\r\n    getIndex(nodeIndex: number, rect: iBound) {\r\n        let indexes = 0b0,\r\n            verticalMidpoint = this.nodeX[nodeIndex],\r\n            horizontalMidpoint = this.nodeY[nodeIndex];\r\n\r\n        const startIsNorth = rect[1] - rect[3] < horizontalMidpoint,\r\n            startIsWest = rect[0] - rect[2] < verticalMidpoint,\r\n            endIsEast = rect[0] + rect[2] > verticalMidpoint,\r\n            endIsSouth = rect[1] + rect[3] > horizontalMidpoint;\r\n\r\n        //lt\r\n        if (startIsWest && startIsNorth) {\r\n            indexes = indexes | 0b1;\r\n        }\r\n\r\n        //rt\r\n        if (startIsNorth && endIsEast) {\r\n            indexes = indexes | 0b10;\r\n        }\r\n\r\n        //rb\r\n        if (endIsEast && endIsSouth) {\r\n            indexes = indexes | 0b100;\r\n        }\r\n\r\n        //lb\r\n        if (startIsWest && endIsSouth) {\r\n            indexes = indexes | 0b1000;\r\n        }\r\n\r\n        return indexes;\r\n    }\r\n\r\n    merge(boundOffset: number) {\r\n        this.nodesRef.set([0, 0, 0, 0], boundOffset);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number} nodeIndex\r\n     * @param {iBound} rect\r\n     * @returns {boolean}\r\n     */\r\n    inside(nodeIndex: number, rect: iBound) {\r\n        const diffX = this.nodeX[nodeIndex] - rect[0];\r\n        const diffY = this.nodeY[nodeIndex] - rect[1];\r\n        const diffW = this.nodeW[nodeIndex] - rect[2];\r\n        const diffH = this.nodeH[nodeIndex] - rect[3];\r\n        return diffW <= 0 && diffH <= 0 && diffX - diffW >= 0 && diffY - diffH >= 0 && diffX + diffW <= 0 && diffY + diffH <= 0;\r\n    }\r\n\r\n    insertBatch(boundOffset: number, rect: iBound, method: string) {\r\n        const binaryIndexes = this.getIndex(boundOffset / 4, rect);\r\n        binaryIndexes & 0b1 && this[method](this.nodesRef[boundOffset], rect);\r\n        binaryIndexes & 0b10 && this[method](this.nodesRef[boundOffset + 1], rect);\r\n        binaryIndexes & 0b100 && this[method](this.nodesRef[boundOffset + 2], rect);\r\n        binaryIndexes & 0b1000 && this[method](this.nodesRef[boundOffset + 3], rect);\r\n    }\r\n\r\n    insert(nodeIndex: number, rect: iBound) {\r\n        const boundOffset = nodeIndex * 4;\r\n        const newCoverTest = this.inside(nodeIndex, rect);\r\n        if (newCoverTest === true) {\r\n            if (this.nodesCovered[nodeIndex] !== 1) {\r\n                this.merge(boundOffset);\r\n                this.nodesTaken[nodeIndex] = 1;\r\n                this.nodesCovered[nodeIndex] = 1;\r\n            }\r\n        } else {\r\n            if (this.nodesLevel[nodeIndex] < this.cellDepthMax && !this.nodesCovered[nodeIndex] && !this.nodesRef[boundOffset]) {\r\n                this.split(nodeIndex);\r\n            }\r\n\r\n            if (this.nodesRef[boundOffset]) {\r\n                this.insertBatch(boundOffset, rect, \"insert\");\r\n            }\r\n\r\n            if (this.nodesRef[boundOffset] === 0) {\r\n                this.nodesTaken[nodeIndex] = 1;\r\n            } else {\r\n                this.nodesTaken[nodeIndex] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n"],"names":["width","height","maxDepth","boundSize","Math","min","grid","constructor","cellDepthMax","cellBatchSize","nodeAnchor","this","cellMinSize","pow","nodeX","Float32Array","nodeY","nodeW","nodeH","nodesRef","Int32Array","nodesLevel","Int8Array","nodesCovered","nodesTaken","newNode","mx","my","hw","hh","level","nodeIndex","split","boundOffset","nextLevel","x","y","subWidth","subHeight","set","getIndex","rect","indexes","verticalMidpoint","horizontalMidpoint","startIsNorth","startIsWest","endIsEast","endIsSouth","merge","inside","diffX","diffY","diffW","diffH","insertBatch","method","binaryIndexes","insert","states","rects","canvas","document","getElementById","setAttribute","style","background","ctx","getContext","_drawGridNodes","i","strokeStyle","strokeRect","_getBound","_drawGridTaken","fillStyle","_drawGridTakenStroke","w","h","render","clearRect","innerText","length","window","requestAnimationFrame","addNodes","amount","large","arrSize","ceil","sqrt","arr","Array","fill","forEach","ignore","r","c","push","start","performance","now","startUi","console","log"],"sourceRoot":""}