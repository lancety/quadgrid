(()=>{"use strict";function e(e,t){return{bound:e,level:t,nodes:[],rects:[]}}const t=1200,s=1e3;let n=0,o=Math.min(t,s);for(;o>2;)o/=2,n++;const r=new class{constructor(t,s,n=6,o=10){this.width=t,this.height=s,this.cellDepthMax=n,this.cellItemsMax=o,this._times=[],this._timesCovered=[],this.root=e([t/2,s/2,t/2,s/2],0)}split(t){const s=t.level+1,n=t.bound[0],o=t.bound[1],r=t.bound[2]/2,i=t.bound[3]/2;t.nodes[0]=e([n-r,o-i,r,i],s),t.nodes[1]=e([n+r,o-i,r,i],s),t.nodes[2]=e([n+r,o+i,r,i],s),t.nodes[3]=e([n-r,o+i,r,i],s)}getIndex(e,t){let s=0,n=e.bound[0],o=e.bound[1];const r=t[1]<o,i=t[0]<n,l=t[0]+t[2]>n,c=t[1]+t[3]>o;return i&&r&&(s|=1),r&&l&&(s|=2),l&&c&&(s|=4),i&&c&&(s|=8),s}merge(e){e.rects.push(...this.allRects([],e)),e.nodes.splice(0)}inside(e,t){return e[0]-e[2]>t[0]&&e[1]-e[3]>t[1]&&e[0]+e[2]<t[0]+t[2]&&e[1]+e[3]<t[1]+t[3]}insertBatch(e,t,s){const n=this.getIndex(e,t);1&n&&this[s](e.nodes[0],t),2&n&&this[s](e.nodes[1],t),4&n&&this[s](e.nodes[2],t),8&n&&this[s](e.nodes[3],t)}insertAsGrid(e,t){!0===this.inside(e.bound,t)?(!0!==e.covered&&(this.merge(e),e.taken=!0,e.covered=!0),e.rects.push(t),this._timesCovered.push(performance.now(),e.bound,e.level)):(e.rects.push(t),e.nodes.length?(this.insertBatch(e,t,"insertAsGrid"),e.rects.splice(0)):!0!==e.covered&&e.level<this.cellDepthMax&&(this.split(e),e.rects.forEach((t=>{this.insertBatch(e,t,"insertAsGrid")})),e.rects.splice(0)),0===e.nodes.length&&e.rects.length>0?e.taken=!0:delete e.taken,this._times.push(performance.now(),e.bound,e.level))}insertAsTree(e,t){e.nodes.length?this.insertBatch(e,t,"insertAsTree"):(e.rects.push(t),e.rects.length>this.cellItemsMax&&e.level<this.cellDepthMax&&(e.nodes.length||this.split(e),e.rects.forEach((t=>this.insertBatch(e,t,"insertAsTree"))),e.rects.splice(0)))}allNodes(e,t){return t.nodes.length>0?t.nodes.forEach((t=>{this.allNodes(e,t)})):e.push(t),e}allRects(e,t){return t.nodes.length>0?t.nodes.forEach((t=>{this.allRects(e,t)})):e.push(...t.rects),e}retrieve(e,t,s){const n=this.getIndex(e,t),o=s||[];if(e.nodes.length&&(1&n&&this.retrieve(e.nodes[0],t,o),2&n&&this.retrieve(e.nodes[1],t,o),4&n&&this.retrieve(e.nodes[2],t,o),8&n&&this.retrieve(e.nodes[3],t,o)),!s)return new Set(o);0===e.nodes.length&&s.push(...e.rects)}clear(){this.root.nodes.splice(0),this.root.rects.splice(0),delete this.root.taken,delete this.root.covered}}(t,s,n,2),i=[0,0,50,50],l={activeRects:new Set,rects:[]},c=document.getElementById("canvas");c.setAttribute("width","1200"),c.setAttribute("height","1000"),c.style.background="#111";const d=c.getContext("2d");let h=!1;function a(e,t){return Math.round(e+Math.random()*(t-e))}function u(e){e.nodes.length?e.nodes.forEach((e=>u(e))):e.taken||(d.strokeStyle="rgba(0, 255, 0, 0.4)",d.strokeRect(...v(e.bound)))}function f(e){e.nodes.length?e.nodes.forEach((e=>f(e))):e.taken&&(d.fillStyle="rgba(255,255,255, 0.8)",d.fillRect(...v(e.bound)))}function g(e){e.nodes.length?e.nodes.forEach((e=>g(e))):e.taken&&(d.strokeStyle="rgba(6, 6, 6, 0.8)",d.strokeRect(...v(e.bound)))}function v(e){return[e[0]-e[2],e[1]-e[3],2*e[2],2*e[3]]}c.addEventListener("mousemove",(function(e){h=!0,e.offsetX||(e.offsetX=e.layerX-e.target.offsetLeft,e.offsetY=e.layerY-e.target.offsetTop),i[0]=e.offsetX-i[2]/2,i[1]=e.offsetY-i[3]/2})),c.addEventListener("mouseout",(function(e){h=!1})),function e(){var n;h&&(l.activeRects.clear(),l.activeRects=r.retrieve(r.root,i)),d.clearRect(0,0,t,s),document.getElementById("info_count").innerText=l.rects.length+"",document.getElementById("info_involved").innerText=((null===(n=l.activeRects)||void 0===n?void 0:n.size)||0)+"",h&&(d.fillStyle="rgba(255,255,255,0.5)",d.fillRect(...i)),u(r.root),f(r.root),g(r.root),l.rects.forEach((e=>{l.activeRects.has(e)?(d.fillStyle="rgba(0, 255, 0, 0.5)",d.fillRect(...e)):(d.strokeStyle="rgba(255, 0, 0, 1)",d.strokeRect(...e))})),window.requestAnimationFrame(e)}(),window.addNodes=function(e,n=!1){l.rects.push(...Array(e).fill(null).map(((o,r)=>{const i=a(2,10)*(n||e>=10&&r<.1*e?30:1)/2,l=a(2,10)*(n||e>=10&&r<.1*e?30:1)/2;return[a(i,t-i),a(l,s-l),i,l]})));const o=performance.now();for(let e=0;e<l.rects.length;e++)r.insertAsGrid(r.root,l.rects[e]);const i=performance.now();console.log(`add ${e} duration`,i-o),console.log("allNodes",r.allNodes([],r.root)),console.log("times",r._times.length/3,r._times),console.log("timesCovered",r._timesCovered.length/3,r._timesCovered)}})();
//# sourceMappingURL=demo.bundle.js.map