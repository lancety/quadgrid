{"version":3,"file":"demo.bundle.js","mappings":"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","sources":["webpack:///./lib/quadgrid.ts","webpack:///./demo.ts"],"sourcesContent":["import {iBound, iQuadGrid, iQuadNode} from \"./quadgrid.type\";\r\n\r\nexport function QuadNode(bound: iBound, level: number): iQuadNode {\r\n    return {\r\n        bound,\r\n        level,\r\n        nodes: [],\r\n    }\r\n}\r\n\r\nexport class QuadGrid implements iQuadGrid {\r\n    root: iQuadNode;\r\n    cellMinSize: number;\r\n\r\n    constructor(public width, public height,\r\n                public cellDepthMax = 6, public cellItemsMax = 10) {\r\n        this.cellMinSize = Math.min(width, height) / Math.pow(2, cellDepthMax);\r\n        this.root = QuadNode([width / 2, height / 2, width / 2, height / 2], 0);\r\n    }\r\n\r\n    split(node: iQuadNode) {\r\n        const nextLevel = node.level + 1,\r\n            x = node.bound[0],\r\n            y = node.bound[1],\r\n            subWidth = node.bound[2] / 2,\r\n            subHeight = node.bound[3] / 2;\r\n\r\n        node.nodes.push(\r\n            //lt\r\n            QuadNode([\r\n                x - subWidth,\r\n                y - subHeight,\r\n                subWidth,\r\n                subHeight\r\n            ], nextLevel),\r\n\r\n            //rt\r\n            QuadNode([\r\n                x + subWidth,\r\n                y - subHeight,\r\n                subWidth,\r\n                subHeight\r\n            ], nextLevel),\r\n\r\n            //rb\r\n            QuadNode([\r\n                x + subWidth,\r\n                y + subHeight,\r\n                subWidth,\r\n                subHeight\r\n            ], nextLevel),\r\n\r\n            //lb\r\n            QuadNode([\r\n                x - subWidth,\r\n                y + subHeight,\r\n                subWidth,\r\n                subHeight\r\n            ], nextLevel),)\r\n    }\r\n\r\n    getIndex(node: iQuadNode, rect: iBound) {\r\n        let indexes = 0b0,\r\n            verticalMidpoint = node.bound[0] ,\r\n            horizontalMidpoint = node.bound[1];\r\n\r\n        const startIsNorth = rect[1] - rect[3] < horizontalMidpoint,\r\n            startIsWest = rect[0] - rect[2] < verticalMidpoint,\r\n            endIsEast = rect[0] + rect[2] > verticalMidpoint,\r\n            endIsSouth = rect[1] + rect[3] > horizontalMidpoint;\r\n\r\n        //lt\r\n        if (startIsWest && startIsNorth) {\r\n            indexes = indexes | 0b1;\r\n        }\r\n\r\n        //rt\r\n        if (startIsNorth && endIsEast) {\r\n            indexes = indexes | 0b10;\r\n        }\r\n\r\n        //rb\r\n        if (endIsEast && endIsSouth) {\r\n            indexes = indexes | 0b100;\r\n        }\r\n\r\n        //lb\r\n        if (startIsWest && endIsSouth) {\r\n            indexes = indexes | 0b1000;\r\n        }\r\n\r\n        return indexes;\r\n    }\r\n\r\n    merge(node: iQuadNode) {\r\n        node.nodes.splice(0);\r\n    }\r\n\r\n    inside(bound: iBound, rect: iBound) {\r\n        return bound[0] - bound[2] > rect[0] - rect[2] && bound[1] - bound[3] > rect[1] - rect[3] &&\r\n            bound[0] + bound[2] < rect[0] + rect[2] &&\r\n            bound[1] + bound[3] < rect[1] + rect[3];\r\n    }\r\n\r\n    insertBatch(node: iQuadNode, rect: iBound, method: string) {\r\n        const binaryIndexes = this.getIndex(node, rect);\r\n        binaryIndexes & 0b1 && this[method](node.nodes[0], rect);\r\n        binaryIndexes & 0b10 && this[method](node.nodes[1], rect);\r\n        binaryIndexes & 0b100 && this[method](node.nodes[2], rect);\r\n        binaryIndexes & 0b1000 && this[method](node.nodes[3], rect);\r\n    }\r\n\r\n    insert(node: iQuadNode, rect: iBound) {\r\n        const newCoverTest = this.inside(node.bound, rect);\r\n        if (newCoverTest === true) {\r\n            if (node.covered !== true) {\r\n                this.merge(node);\r\n                node.taken = true;\r\n                node.covered = true;\r\n            }\r\n        } else {\r\n            if (node.level < this.cellDepthMax && !node.covered && !node.nodes.length) {\r\n                this.split(node);\r\n            }\r\n\r\n            if (node.nodes.length) {\r\n                this.insertBatch(node, rect, \"insert\");\r\n            }\r\n\r\n            if (node.nodes.length === 0) {\r\n                node.taken = true;\r\n            } else {\r\n                delete node.taken;\r\n            }\r\n        }\r\n    }\r\n\r\n    allNodes(nodeStore: iQuadNode[], node: iQuadNode): iQuadNode[] {\r\n        if (node.nodes.length > 0) {\r\n            node.nodes.forEach(n => {\r\n                this.allNodes(nodeStore, n);\r\n            })\r\n        } else {\r\n            nodeStore.push(node);\r\n        }\r\n        return nodeStore;\r\n    }\r\n}\r\n","import {QuadGrid} from \"./lib/quadgrid\";\r\nimport {iBound, iQuadNode} from \"./lib/quadgrid.type\";\r\n\r\nconst width = 1200, height = 1000;\r\nconst min = 2, max = 10;\r\n\r\nlet maxDepth = 0, maxItems = 2;\r\nlet boundSize = Math.min(width, height);\r\nwhile (boundSize > min) {\r\n    boundSize /= 2;\r\n    maxDepth++;\r\n}\r\n\r\nconst grid = new QuadGrid(width, height, maxDepth, maxItems);\r\n\r\n/*\r\n* states\r\n* */\r\nconst states = {\r\n    rects: [] as iBound[],\r\n}\r\n\r\n/*\r\n* init UI\r\n* */\r\nconst canvas = document.getElementById(\"canvas\")\r\ncanvas.setAttribute(\"width\", width + \"\");\r\ncanvas.setAttribute(\"height\", height + \"\");\r\ncanvas.style.background = \"#111\";\r\nconst ctx = (canvas as HTMLCanvasElement).getContext('2d');\r\n\r\n\r\n/*\r\n* mouse event\r\n* */\r\n\r\n\r\n/*\r\n* main\r\n* */\r\n\r\n(function render() {\r\n    _updateUI();\r\n    window.requestAnimationFrame(render);\r\n})()\r\n\r\n\r\n/*\r\n* quadtree util\r\n* */\r\nfunction _random(min, max) {\r\n    return Math.round(min + (Math.random() * (max - min)));\r\n}\r\n\r\n(window as any).addNodes = function (amount: number, large = false) {\r\n    const arrSize = Math.ceil(Math.sqrt(amount));\r\n    const arr = Array(arrSize).fill(null);\r\n    arr.forEach((ignore, r) => {\r\n        arr.forEach((ignore, c) => {\r\n            // const w = _random(min, max) * (large ? 30 : 1) / 2;\r\n            // const h = _random(min, max) * (large ? 30 : 1) / 2;\r\n            const w = _random(min, max) * (large || (amount >= 10 && r < arrSize * 0.2) ? 20 : 1) / 2;\r\n            const h = _random(min, max) * (large || (amount >= 10 && c < arrSize * 0.2) ? 20 : 1) / 2;\r\n            states.rects.push( [\r\n                _random(w, width - w),\r\n                _random(h, height - h),\r\n                w,\r\n                h,\r\n            ] as iBound)\r\n\r\n\r\n            // const w  =min * (large || (amount >= 10 && r < amount * 0.1) ? 30 : 1) / 2;\r\n            // const h = min * (large || (amount >= 10 && c < amount * 0.1) ? 30 : 1) / 2;\r\n            // states.rects.push( [\r\n            //     w * 3 * r * 1.1 + w,\r\n            //     h * 3 * c * 1.1 + h,\r\n            //     w,\r\n            //     h,\r\n            // ] as iBound)\r\n        })\r\n\r\n    })\r\n\r\n    const start = performance.now();\r\n    for (let i = 0; i < states.rects.length; i++) {\r\n        grid.insert(grid.root, states.rects[i])\r\n    }\r\n    const startUi = performance.now();\r\n    console.log(`add ${amount} duration`, startUi - start)\r\n    console.log(`allNodes`, grid.allNodes([], grid.root));\r\n}\r\n\r\n\r\n/*\r\n* render util\r\n* */\r\nfunction _updateUI() {\r\n    ctx.clearRect(0, 0, width, height);\r\n\r\n    document.getElementById(\"info_count\").innerText = states.rects.length + \"\";\r\n\r\n    // draw grid\r\n    _drawGridNodes(grid.root);\r\n    _drawGridTaken(grid.root);\r\n    _drawGridTakenStroke(grid.root);\r\n}\r\n\r\nfunction _drawGridNodes(node: iQuadNode) {\r\n    if (node.nodes.length) {\r\n        node.nodes.forEach(node => _drawGridNodes(node));\r\n    } else {\r\n        if (!node.taken) {\r\n            ctx.strokeStyle = \"rgba(0, 255, 0, 0.4)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(node.bound))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _drawGridTaken(node: iQuadNode) {\r\n    if (node.nodes.length) {\r\n        node.nodes.forEach(node => _drawGridTaken(node));\r\n    } else {\r\n        if (node.taken) {\r\n            ctx.fillStyle = \"rgba(6, 6, 6, 0.8)\";\r\n            // @ts-ignore\r\n            ctx.fillRect(..._getBound(node.bound))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _drawGridTakenStroke(node: iQuadNode) {\r\n    if (node.nodes.length) {\r\n        node.nodes.forEach(node => _drawGridTakenStroke(node));\r\n    } else {\r\n        if (node.taken) {\r\n            ctx.strokeStyle = \"rgba(152,11,11,0.8)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(node.bound))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _getBound(bound: iBound) {\r\n    return [bound[0] - bound[2], bound[1] - bound[3], bound[2] * 2, bound[3] * 2];\r\n}"],"names":["QuadNode","bound","level","nodes","width","height","maxDepth","boundSize","Math","min","grid","constructor","cellDepthMax","cellItemsMax","this","cellMinSize","pow","root","split","node","nextLevel","x","y","subWidth","subHeight","push","getIndex","rect","indexes","verticalMidpoint","horizontalMidpoint","startIsNorth","startIsWest","endIsEast","endIsSouth","merge","splice","inside","insertBatch","method","binaryIndexes","insert","covered","taken","length","allNodes","nodeStore","forEach","n","states","rects","canvas","document","getElementById","setAttribute","style","background","ctx","getContext","_random","max","round","random","_drawGridNodes","strokeStyle","strokeRect","_getBound","_drawGridTaken","fillStyle","fillRect","_drawGridTakenStroke","render","clearRect","innerText","window","requestAnimationFrame","addNodes","amount","large","arrSize","ceil","sqrt","arr","Array","fill","ignore","r","c","w","h","start","performance","now","i","startUi","console","log"],"sourceRoot":""}