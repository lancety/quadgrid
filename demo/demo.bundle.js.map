{"version":3,"file":"demo.bundle.js","mappings":"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","sources":["webpack:///./lib/quadgrid.type.ts","webpack:///./demo.ts","webpack:///./lib/quadgrid.ts"],"sourcesContent":["export interface iQuadGrid {\r\n    cellItemsMax?: number,\r\n    cellDepthMax?: number,\r\n    cellMinSize?: number,\r\n\r\n    nodeBounds: bBound,\r\n    nodesInfo: bNodeInfo,\r\n    nodesRef: bNode,\r\n}\r\n\r\n\r\nexport interface iQuadNode {\r\n    bound: iBound,      // bound of this node\r\n    level: number,      // this node's level\r\n    nodes?: iQuadNode[], // 4 child nodes\r\n    rects?: iBound[],  // iBound , only quadTree need it, quadGrid dont need\r\n    covered?: boolean,   // node is totally inside a bound area\r\n    taken?: boolean,     // node has at least one bound object\r\n}\r\n\r\n\r\nexport type iBound = number[];  // x, y, width, height,\r\n\r\n// 0 to 65535\r\nexport type bBound = Float32Array;    // [mx, my, hw, hh]\r\nexport type bNode = Int32Array;      // [ltId, rtId, rbId, lbId]\r\nexport type bNodeInfo = Int8Array;     // [level, covered, taken]\r\n\r\nexport const epNodeInfo = {\r\n    level: 0,\r\n    covered: 1,\r\n    taken: 2,\r\n}","import {QuadGrid} from \"./lib/quadgrid\";\r\nimport {epNodeInfo, iBound} from \"./lib/quadgrid.type\";\r\n\r\nconst width = 1200, height = 1000;\r\nconst min = 2, max = 20;\r\n\r\nlet maxDepth = 0;\r\nlet boundSize = Math.min(width, height);\r\nwhile (boundSize > min) {\r\n    boundSize /= 2;\r\n    maxDepth++;\r\n}\r\n\r\nconst grid = new QuadGrid(width, height, maxDepth);\r\n\r\n/*\r\n* states\r\n* */\r\nconst states = {\r\n    rects: [] as iBound[],\r\n}\r\n\r\n/*\r\n* init UI\r\n* */\r\nconst canvas = document.getElementById(\"canvas\")\r\ncanvas.setAttribute(\"width\", width + \"\");\r\ncanvas.setAttribute(\"height\", height + \"\");\r\ncanvas.style.background = \"#111\";\r\nconst ctx = (canvas as HTMLCanvasElement).getContext('2d');\r\n\r\n\r\n/*\r\n* mouse event\r\n* */\r\n\r\n\r\n/*\r\n* main\r\n* */\r\n\r\n(function render() {\r\n    _updateUI();\r\n    window.requestAnimationFrame(render);\r\n})()\r\n\r\n\r\n/*\r\n* quadtree util\r\n* */\r\nfunction _random(min, max) {\r\n    return Math.round(min + (Math.random() * (max - min)));\r\n}\r\n\r\n(window as any).addNodes = function (amount: number, large = false) {\r\n    const arrSize = Math.ceil(Math.sqrt(amount));\r\n    const arr = Array(arrSize).fill(null);\r\n    arr.forEach((ignore, r) => {\r\n        arr.forEach((ignore, c) => {\r\n            // const w = _random(min, max) * (large ? 30 : 1) / 2;\r\n            // const h = _random(min, max) * (large ? 30 : 1) / 2;\r\n            const w = _random(min, max) * (large || (amount >= 10 && r < arrSize * 0.1) ? 20 : 1) / 2;\r\n            const h = _random(min, max) * (large || (amount >= 10 && c < arrSize * 0.1) ? 20 : 1) / 2;\r\n            states.rects.push([\r\n                _random(w, width - w),\r\n                _random(h, height - h),\r\n                w,\r\n                h,\r\n            ] as iBound)\r\n\r\n            // const w  =min * (large || (amount >= 10 && r < amount * 0.1) ? 30 : 1) / 2;\r\n            // const h = min * (large || (amount >= 10 && c < amount * 0.1) ? 30 : 1) / 2;\r\n            // states.rects.push( [\r\n            //     w * 3 * r * 1.1 + w,\r\n            //     h * 3 * c * 1.1 + h,\r\n            //     w,\r\n            //     h,\r\n            // ] as iBound)\r\n        })\r\n\r\n    })\r\n\r\n    const start = performance.now();\r\n    for (let i = 0; i < states.rects.length; i++) {\r\n        grid.insert(0, states.rects[i])\r\n    }\r\n    const startUi = performance.now();\r\n    console.log(`add ${amount} duration`, startUi - start)\r\n    console.log(`allNodes`, grid.nodeAnchor);\r\n}\r\n\r\n\r\n/*\r\n* render util\r\n* */\r\nfunction _updateUI() {\r\n    if (grid.nodeAnchor === 1) return;\r\n    ctx.clearRect(0, 0, width, height);\r\n\r\n    document.getElementById(\"info_count\").innerText = states.rects.length + \"\";\r\n\r\n    // draw grid\r\n    _drawGridNodes();\r\n    _drawGridTaken();\r\n    _drawGridTakenStroke();\r\n}\r\n\r\nfunction _drawGridNodes(nodeIndex?: number) {\r\n    if (nodeIndex === 0) return;\r\n    const boundOffset = (nodeIndex || 0) * 4;\r\n    if (grid.nodesRef[boundOffset]) {\r\n        for (let i = 0; i < 4; i++) {\r\n            _drawGridNodes(grid.nodesRef[boundOffset + i])\r\n        }\r\n    } else {\r\n        const infoOffset = nodeIndex * grid.nodesInfoSize;\r\n        if (!grid.nodesInfo[infoOffset + epNodeInfo.taken]) {\r\n            ctx.strokeStyle = \"rgba(0, 255, 0, 0.4)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(grid.nodeBounds.subarray(boundOffset, boundOffset + 4)))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _drawGridTaken(nodeIndex?: number) {\r\n    if (nodeIndex === 0) return;\r\n    const boundOffset = (nodeIndex || 0) * 4;\r\n    if (grid.nodesRef[boundOffset]) {\r\n        for (let i = 0; i < 4; i++) {\r\n            _drawGridTaken(grid.nodesRef[boundOffset + i])\r\n        }\r\n    } else {\r\n        const infoOffset = nodeIndex * grid.nodesInfoSize;\r\n        if (grid.nodesInfo[infoOffset + epNodeInfo.taken]) {\r\n            ctx.fillStyle = \"rgba(6, 6, 6, 0.8)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(grid.nodeBounds.subarray(boundOffset, boundOffset + 4)))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _drawGridTakenStroke(nodeIndex?: number) {\r\n    if (nodeIndex === 0) return;\r\n    const boundOffset = (nodeIndex || 0) * 4;\r\n    if (grid.nodesRef[boundOffset]) {\r\n        for (let i = 0; i < 4; i++) {\r\n            _drawGridTakenStroke(grid.nodesRef[boundOffset + i])\r\n        }\r\n    } else {\r\n        const infoOffset = nodeIndex * grid.nodesInfoSize;\r\n        if (grid.nodesInfo[infoOffset + epNodeInfo.taken]) {\r\n            ctx.strokeStyle = \"rgba(152,11,11,0.8)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(grid.nodeBounds.subarray(boundOffset, boundOffset + 4)))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _getBound(bound: iBound) {\r\n    return [bound[0] - bound[2], bound[1] - bound[3], bound[2] * 2, bound[3] * 2];\r\n}","import {epNodeInfo, iBound, iQuadGrid, iQuadNode} from \"./quadgrid.type\";\r\n\r\nexport class QuadGrid implements iQuadGrid {\r\n    cellMinSize: number;\r\n    cellBatchSize = 100000;\r\n\r\n    nodeBounds: Float32Array;\r\n    nodesInfo: Int8Array;\r\n    nodesInfoSize = Object.keys(epNodeInfo).length;  // [level, covered, taken]\r\n    nodesRef: Int32Array;\r\n\r\n    nodeAnchor = 0;\r\n\r\n    constructor(public width, public height,\r\n                public cellDepthMax = 6) {\r\n        this.cellMinSize = Math.min(width, height) / Math.pow(2, cellDepthMax);\r\n\r\n        this.nodeBounds = new Float32Array(this.cellBatchSize * 4);\r\n        this.nodesRef = new Int32Array(this.cellBatchSize * 4);\r\n        this.nodesInfo = new Int8Array(this.cellBatchSize * this.nodesInfoSize);\r\n\r\n        this.newNode(width / 2, height / 2, width / 2, height / 2, 0);\r\n    }\r\n\r\n    newNode(mx: number, my: number, hw: number, hh: number, level: number) {\r\n        const offset = this.nodeAnchor * 4;\r\n        this.nodeBounds[offset] = mx;\r\n        this.nodeBounds[offset+1] = my;\r\n        this.nodeBounds[offset+2] = hw;\r\n        this.nodeBounds[offset+3] = hh;\r\n        this.nodesInfo[this.nodeAnchor * 3] = level;\r\n        const nodeIndex = this.nodeAnchor;\r\n        this.nodeAnchor++;\r\n        return nodeIndex;\r\n    }\r\n\r\n\r\n    split(nodeIndex: number) {\r\n        const boundOffset = nodeIndex * 4;\r\n        const nextLevel = this.nodesInfo[nodeIndex * this.nodesInfoSize + epNodeInfo.level] + 1,\r\n            x = this.nodeBounds[boundOffset],\r\n            y = this.nodeBounds[boundOffset + 1],\r\n            subWidth = this.nodeBounds[boundOffset + 2] / 2,\r\n            subHeight = this.nodeBounds[boundOffset + 3] / 2;\r\n\r\n        this.nodesRef.set([\r\n            this.newNode(x - subWidth, y - subHeight, subWidth, subHeight, nextLevel), //lt\r\n            this.newNode(x + subWidth, y - subHeight, subWidth, subHeight, nextLevel), //rt\r\n            this.newNode(x + subWidth, y + subHeight, subWidth, subHeight, nextLevel), //rb\r\n            this.newNode(x - subWidth, y + subHeight, subWidth, subHeight, nextLevel), //lb\r\n        ], boundOffset);\r\n    }\r\n\r\n    getIndex(boundOffset: number, rect: iBound) {\r\n        let indexes = 0b0,\r\n            verticalMidpoint = this.nodeBounds[boundOffset],\r\n            horizontalMidpoint = this.nodeBounds[boundOffset + 1];\r\n\r\n        const startIsNorth = rect[1] - rect[3] < horizontalMidpoint,\r\n            startIsWest = rect[0] - rect[2] < verticalMidpoint,\r\n            endIsEast = rect[0] + rect[2] > verticalMidpoint,\r\n            endIsSouth = rect[1] + rect[3] > horizontalMidpoint;\r\n\r\n        //lt\r\n        if (startIsWest && startIsNorth) {\r\n            indexes = indexes | 0b1;\r\n        }\r\n\r\n        //rt\r\n        if (startIsNorth && endIsEast) {\r\n            indexes = indexes | 0b10;\r\n        }\r\n\r\n        //rb\r\n        if (endIsEast && endIsSouth) {\r\n            indexes = indexes | 0b100;\r\n        }\r\n\r\n        //lb\r\n        if (startIsWest && endIsSouth) {\r\n            indexes = indexes | 0b1000;\r\n        }\r\n\r\n        return indexes;\r\n    }\r\n\r\n    merge(boundOffset: number) {\r\n        this.nodesRef.set([0, 0, 0, 0], boundOffset);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number} offset   nodeBounds index offset\r\n     * @param {iBound} rect\r\n     * @returns {boolean}\r\n     */\r\n    inside(offset: number, rect: iBound) {\r\n        const diffX = this.nodeBounds[offset] - rect[0];\r\n        const diffY = this.nodeBounds[offset + 1] - rect[1];\r\n        const diffW = this.nodeBounds[offset + 2] - rect[2];\r\n        const diffH = this.nodeBounds[offset + 3] - rect[3];\r\n        return diffW <= 0 && diffH <= 0 && diffX - diffW >= 0 && diffY - diffH >= 0 && diffX + diffW <= 0 && diffY + diffH <= 0;\r\n    }\r\n\r\n    insertBatch(boundOffset: number, rect: iBound, method: string) {\r\n        const binaryIndexes = this.getIndex(boundOffset, rect);\r\n        binaryIndexes & 0b1 && this[method](this.nodesRef[boundOffset], rect);\r\n        binaryIndexes & 0b10 && this[method](this.nodesRef[boundOffset + 1], rect);\r\n        binaryIndexes & 0b100 && this[method](this.nodesRef[boundOffset + 2], rect);\r\n        binaryIndexes & 0b1000 && this[method](this.nodesRef[boundOffset + 3], rect);\r\n    }\r\n\r\n    insert(nodeIndex: number, rect: iBound) {\r\n        const boundOffset = nodeIndex * 4;\r\n        const infoOffset = nodeIndex * this.nodesInfoSize;\r\n        const newCoverTest = this.inside(boundOffset, rect);\r\n        if (newCoverTest === true) {\r\n            if (this.nodesInfo[infoOffset + epNodeInfo.covered] !== 1) {\r\n                this.merge(boundOffset);\r\n                this.nodesInfo[infoOffset + epNodeInfo.taken] = 1;\r\n                this.nodesInfo[infoOffset + epNodeInfo.covered] = 1;\r\n            }\r\n        } else {\r\n            if (this.nodesInfo[infoOffset + epNodeInfo.level] < this.cellDepthMax && !this.nodesInfo[infoOffset + epNodeInfo.covered] && !this.nodesRef[boundOffset]) {\r\n                this.split(nodeIndex);\r\n            }\r\n\r\n            if (this.nodesRef[boundOffset]) {\r\n                this.insertBatch(boundOffset, rect, \"insert\");\r\n            }\r\n\r\n            if (this.nodesRef[boundOffset] === 0) {\r\n                this.nodesInfo[infoOffset + epNodeInfo.taken] = 1;\r\n            } else {\r\n                this.nodesInfo[infoOffset + epNodeInfo.taken] = 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"names":["epNodeInfo","level","covered","taken","width","height","maxDepth","boundSize","Math","min","grid","constructor","cellDepthMax","cellBatchSize","nodesInfoSize","Object","keys","length","nodeAnchor","this","cellMinSize","pow","nodeBounds","Float32Array","nodesRef","Int32Array","nodesInfo","Int8Array","newNode","mx","my","hw","hh","offset","nodeIndex","split","boundOffset","nextLevel","x","y","subWidth","subHeight","set","getIndex","rect","indexes","verticalMidpoint","horizontalMidpoint","startIsNorth","startIsWest","endIsEast","endIsSouth","merge","inside","diffX","diffY","diffW","diffH","insertBatch","method","binaryIndexes","insert","infoOffset","states","rects","canvas","document","getElementById","setAttribute","style","background","ctx","getContext","_random","max","round","random","_drawGridNodes","i","strokeStyle","strokeRect","_getBound","subarray","_drawGridTaken","fillStyle","_drawGridTakenStroke","bound","render","clearRect","innerText","window","requestAnimationFrame","addNodes","amount","large","arrSize","ceil","sqrt","arr","Array","fill","forEach","ignore","r","c","w","h","push","start","performance","now","startUi","console","log"],"sourceRoot":""}