{"version":3,"file":"demo.bundle.js","mappings":"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","sources":["webpack:///./demo.ts","webpack:///./lib/quadgrid.ts"],"sourcesContent":["import {QuadGrid} from \"./lib/quadgrid\";\r\nimport {iBound} from \"./lib/quadgrid.type\";\r\n\r\nconst width = 1200, height = 1000;\r\nconst min = 2, max = 10;\r\n\r\nlet maxDepth = 0;\r\nlet boundSize = Math.min(width, height);\r\nwhile (boundSize > min) {\r\n    boundSize /= 2;\r\n    maxDepth++;\r\n}\r\n\r\nconst grid = new QuadGrid(width, height, maxDepth);\r\n\r\n/*\r\n* states\r\n* */\r\nconst states = {\r\n    rects: [] as iBound[],\r\n}\r\n\r\n/*\r\n* init UI\r\n* */\r\nconst canvas = document.getElementById(\"canvas\")\r\ncanvas.setAttribute(\"width\", width + \"\");\r\ncanvas.setAttribute(\"height\", height + \"\");\r\ncanvas.style.background = \"#111\";\r\nconst ctx = (canvas as HTMLCanvasElement).getContext('2d');\r\n\r\n\r\n/*\r\n* mouse event\r\n* */\r\n\r\n\r\n/*\r\n* main\r\n* */\r\n\r\n(function render() {\r\n    _updateUI();\r\n    window.requestAnimationFrame(render);\r\n})()\r\n\r\n\r\n/*\r\n* quadtree util\r\n* */\r\nfunction _random(min, max) {\r\n    return Math.round(min + (Math.random() * (max - min)));\r\n}\r\n\r\n(window as any).addNodes = function (amount: number, large = false) {\r\n    const arrSize = Math.ceil(Math.sqrt(amount));\r\n    const arr = Array(arrSize).fill(null);\r\n    arr.forEach((ignore, r) => {\r\n        arr.forEach((ignore, c) => {\r\n            // const w = _random(min, max) * (large ? 30 : 1) / 2;\r\n            // const h = _random(min, max) * (large ? 30 : 1) / 2;\r\n            const w = _random(min, max) * (large || (amount >= 10 && r < arrSize * 0.1) ? 20 : 1) / 2;\r\n            const h = _random(min, max) * (large || (amount >= 10 && c < arrSize * 0.1) ? 20 : 1) / 2;\r\n            states.rects.push([\r\n                _random(w, width - w),\r\n                _random(h, height - h),\r\n                w,\r\n                h,\r\n            ] as iBound)\r\n\r\n            // const w  =min * (large || (amount >= 10 && r < amount * 0.1) ? 30 : 1) / 2;\r\n            // const h = min * (large || (amount >= 10 && c < amount * 0.1) ? 30 : 1) / 2;\r\n            // states.rects.push( [\r\n            //     w * 3 * r * 1.1 + w,\r\n            //     h * 3 * c * 1.1 + h,\r\n            //     w,\r\n            //     h,\r\n            // ] as iBound)\r\n        })\r\n\r\n    })\r\n\r\n    const start = performance.now();\r\n    for (let i = 0; i < states.rects.length; i++) {\r\n        grid.insert(0, states.rects[i])\r\n    }\r\n    const startUi = performance.now();\r\n    console.log(`add ${amount} duration`, startUi - start)\r\n    console.log(`allNodes`, grid.nodeAnchor);\r\n}\r\n\r\n\r\n/*\r\n* render util\r\n* */\r\nfunction _updateUI() {\r\n    if (grid.nodeAnchor === 1) return;\r\n    ctx.clearRect(0, 0, width, height);\r\n\r\n    document.getElementById(\"info_count\").innerText = states.rects.length + \"\";\r\n\r\n    // draw grid\r\n    _drawGridNodes();\r\n    _drawGridTaken();\r\n    _drawGridTakenStroke();\r\n}\r\n\r\nfunction _drawGridNodes(nodeIndex?: number) {\r\n    if (nodeIndex === 0) return;\r\n    const boundOffset = (nodeIndex || 0) * 4;\r\n    if (grid.nodesRef[boundOffset]) {\r\n        for (let i = 0; i < 4; i++) {\r\n            _drawGridNodes(grid.nodesRef[boundOffset + i])\r\n        }\r\n    } else {\r\n        if (!grid.nodesTaken[nodeIndex]) {\r\n            ctx.strokeStyle = \"rgba(0, 255, 0, 0.4)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(grid.nodeBounds.subarray(boundOffset, boundOffset + 4)))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _drawGridTaken(nodeIndex?: number) {\r\n    if (nodeIndex === 0) return;\r\n    const boundOffset = (nodeIndex || 0) * 4;\r\n    if (grid.nodesRef[boundOffset]) {\r\n        for (let i = 0; i < 4; i++) {\r\n            _drawGridTaken(grid.nodesRef[boundOffset + i])\r\n        }\r\n    } else {\r\n        if (grid.nodesTaken[nodeIndex]) {\r\n            ctx.fillStyle = \"rgba(6, 6, 6, 0.8)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(grid.nodeBounds.subarray(boundOffset, boundOffset + 4)))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _drawGridTakenStroke(nodeIndex?: number) {\r\n    if (nodeIndex === 0) return;\r\n    const boundOffset = (nodeIndex || 0) * 4;\r\n    if (grid.nodesRef[boundOffset]) {\r\n        for (let i = 0; i < 4; i++) {\r\n            _drawGridTakenStroke(grid.nodesRef[boundOffset + i])\r\n        }\r\n    } else {\r\n        if (grid.nodesTaken[nodeIndex]) {\r\n            ctx.strokeStyle = \"rgba(152,11,11,0.8)\";\r\n            // @ts-ignore\r\n            ctx.strokeRect(..._getBound(grid.nodeBounds.subarray(boundOffset, boundOffset + 4)))\r\n        }\r\n    }\r\n}\r\n\r\nfunction _getBound(bound: iBound) {\r\n    return [bound[0] - bound[2], bound[1] - bound[3], bound[2] * 2, bound[3] * 2];\r\n}","import {iBound, iQuadGrid} from \"./quadgrid.type\";\r\n\r\nexport class QuadGrid implements iQuadGrid {\r\n    cellMinSize: number;\r\n    cellBatchSize = 100000;\r\n\r\n    nodeBounds: Float32Array;\r\n    nodesRef: Int32Array;\r\n\r\n    nodesLevel: Int8Array;\r\n    nodesCovered: Int8Array;\r\n    nodesTaken: Int8Array;\r\n\r\n    nodeAnchor = 0;\r\n\r\n    constructor(public width, public height,\r\n                public cellDepthMax = 6) {\r\n        this.cellMinSize = Math.min(width, height) / Math.pow(2, cellDepthMax);\r\n\r\n        this.nodeBounds = new Float32Array(this.cellBatchSize * 4);\r\n        this.nodesRef = new Int32Array(this.cellBatchSize * 4);\r\n        this.nodesLevel = new Int8Array(this.cellBatchSize);\r\n        this.nodesCovered = new Int8Array(this.cellBatchSize);\r\n        this.nodesTaken = new Int8Array(this.cellBatchSize);\r\n\r\n        this.newNode(width / 2, height / 2, width / 2, height / 2, 0);\r\n    }\r\n\r\n    newNode(mx: number, my: number, hw: number, hh: number, level: number) {\r\n        const offset = this.nodeAnchor * 4;\r\n        this.nodeBounds[offset] = mx;\r\n        this.nodeBounds[offset+1] = my;\r\n        this.nodeBounds[offset+2] = hw;\r\n        this.nodeBounds[offset+3] = hh;\r\n        this.nodesLevel[this.nodeAnchor] = level;\r\n        const nodeIndex = this.nodeAnchor;\r\n        this.nodeAnchor++;\r\n        return nodeIndex;\r\n    }\r\n\r\n\r\n    split(nodeIndex: number) {\r\n        const boundOffset = nodeIndex * 4;\r\n        const nextLevel = this.nodesLevel[nodeIndex] + 1,\r\n            x = this.nodeBounds[boundOffset],\r\n            y = this.nodeBounds[boundOffset + 1],\r\n            subWidth = this.nodeBounds[boundOffset + 2] / 2,\r\n            subHeight = this.nodeBounds[boundOffset + 3] / 2;\r\n\r\n        this.nodesRef.set([\r\n            this.newNode(x - subWidth, y - subHeight, subWidth, subHeight, nextLevel), //lt\r\n            this.newNode(x + subWidth, y - subHeight, subWidth, subHeight, nextLevel), //rt\r\n            this.newNode(x + subWidth, y + subHeight, subWidth, subHeight, nextLevel), //rb\r\n            this.newNode(x - subWidth, y + subHeight, subWidth, subHeight, nextLevel), //lb\r\n        ], boundOffset);\r\n    }\r\n\r\n    getIndex(boundOffset: number, rect: iBound) {\r\n        let indexes = 0b0,\r\n            verticalMidpoint = this.nodeBounds[boundOffset],\r\n            horizontalMidpoint = this.nodeBounds[boundOffset + 1];\r\n\r\n        const startIsNorth = rect[1] - rect[3] < horizontalMidpoint,\r\n            startIsWest = rect[0] - rect[2] < verticalMidpoint,\r\n            endIsEast = rect[0] + rect[2] > verticalMidpoint,\r\n            endIsSouth = rect[1] + rect[3] > horizontalMidpoint;\r\n\r\n        //lt\r\n        if (startIsWest && startIsNorth) {\r\n            indexes = indexes | 0b1;\r\n        }\r\n\r\n        //rt\r\n        if (startIsNorth && endIsEast) {\r\n            indexes = indexes | 0b10;\r\n        }\r\n\r\n        //rb\r\n        if (endIsEast && endIsSouth) {\r\n            indexes = indexes | 0b100;\r\n        }\r\n\r\n        //lb\r\n        if (startIsWest && endIsSouth) {\r\n            indexes = indexes | 0b1000;\r\n        }\r\n\r\n        return indexes;\r\n    }\r\n\r\n    merge(boundOffset: number) {\r\n        this.nodesRef.set([0, 0, 0, 0], boundOffset);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number} offset   nodeBounds index offset\r\n     * @param {iBound} rect\r\n     * @returns {boolean}\r\n     */\r\n    inside(offset: number, rect: iBound) {\r\n        const diffX = this.nodeBounds[offset] - rect[0];\r\n        const diffY = this.nodeBounds[offset + 1] - rect[1];\r\n        const diffW = this.nodeBounds[offset + 2] - rect[2];\r\n        const diffH = this.nodeBounds[offset + 3] - rect[3];\r\n        return diffW <= 0 && diffH <= 0 && diffX - diffW >= 0 && diffY - diffH >= 0 && diffX + diffW <= 0 && diffY + diffH <= 0;\r\n    }\r\n\r\n    insertBatch(boundOffset: number, rect: iBound, method: string) {\r\n        const binaryIndexes = this.getIndex(boundOffset, rect);\r\n        binaryIndexes & 0b1 && this[method](this.nodesRef[boundOffset], rect);\r\n        binaryIndexes & 0b10 && this[method](this.nodesRef[boundOffset + 1], rect);\r\n        binaryIndexes & 0b100 && this[method](this.nodesRef[boundOffset + 2], rect);\r\n        binaryIndexes & 0b1000 && this[method](this.nodesRef[boundOffset + 3], rect);\r\n    }\r\n\r\n    insert(nodeIndex: number, rect: iBound) {\r\n        const boundOffset = nodeIndex * 4;\r\n        const newCoverTest = this.inside(boundOffset, rect);\r\n        if (newCoverTest === true) {\r\n            if (this.nodesCovered[nodeIndex] !== 1) {\r\n                this.merge(boundOffset);\r\n                this.nodesTaken[nodeIndex] = 1;\r\n                this.nodesCovered[nodeIndex] = 1;\r\n            }\r\n        } else {\r\n            if (this.nodesLevel[nodeIndex] < this.cellDepthMax && !this.nodesCovered[nodeIndex] && !this.nodesRef[boundOffset]) {\r\n                this.split(nodeIndex);\r\n            }\r\n\r\n            if (this.nodesRef[boundOffset]) {\r\n                this.insertBatch(boundOffset, rect, \"insert\");\r\n            }\r\n\r\n            if (this.nodesRef[boundOffset] === 0) {\r\n                this.nodesTaken[nodeIndex] = 1;\r\n            } else {\r\n                this.nodesTaken[nodeIndex] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n"],"names":["width","height","maxDepth","boundSize","Math","min","grid","constructor","cellDepthMax","cellBatchSize","nodeAnchor","this","cellMinSize","pow","nodeBounds","Float32Array","nodesRef","Int32Array","nodesLevel","Int8Array","nodesCovered","nodesTaken","newNode","mx","my","hw","hh","level","offset","nodeIndex","split","boundOffset","nextLevel","x","y","subWidth","subHeight","set","getIndex","rect","indexes","verticalMidpoint","horizontalMidpoint","startIsNorth","startIsWest","endIsEast","endIsSouth","merge","inside","diffX","diffY","diffW","diffH","insertBatch","method","binaryIndexes","insert","states","rects","canvas","document","getElementById","setAttribute","style","background","ctx","getContext","_random","max","round","random","_drawGridNodes","i","strokeStyle","strokeRect","_getBound","subarray","_drawGridTaken","fillStyle","_drawGridTakenStroke","bound","render","clearRect","innerText","length","window","requestAnimationFrame","addNodes","amount","large","arrSize","ceil","sqrt","arr","Array","fill","forEach","ignore","r","c","w","h","push","start","performance","now","startUi","console","log"],"sourceRoot":""}