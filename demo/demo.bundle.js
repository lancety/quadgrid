(()=>{"use strict";function e(e,t){return{bound:e,level:t,nodes:[],rects:[]}}const t=1200,s=1e3;let o=0,n=Math.min(t,s);for(;n>2;)n/=2,o++;const r=new class{constructor(t,s,o=6,n=10){this.width=t,this.height=s,this.cellDepthMax=o,this.cellItemsMax=n,this._times=[],this._timesCovered=[],this.cellMinSize=Math.min(t,s)/Math.pow(2,o),this.root=e([t/2,s/2,t/2,s/2],0)}split(t){const s=t.level+1,o=t.bound[0],n=t.bound[1],r=t.bound[2]/2,i=t.bound[3]/2;t.nodes.push(e([o-r,n-i,r,i],s),e([o+r,n-i,r,i],s),e([o+r,n+i,r,i],s),e([o-r,n+i,r,i],s))}getIndex(e,t){let s=0,o=e.bound[0],n=e.bound[1];const r=t[1]-t[3]<n,i=t[0]-t[2]<o,c=t[0]+t[2]>o,l=t[1]+t[3]>n;return i&&r&&(s|=1),r&&c&&(s|=2),c&&l&&(s|=4),i&&l&&(s|=8),s}merge(e){e.rects.push(...this.allRects([],e)),e.nodes.splice(0)}inside(e,t){return e[0]-e[2]>t[0]-t[2]&&e[1]-e[3]>t[1]-t[3]&&e[0]+e[2]<t[0]+t[2]&&e[1]+e[3]<t[1]+t[3]}insertBatch(e,t,s){const o=this.getIndex(e,t);1&o&&this[s](e.nodes[0],t),2&o&&this[s](e.nodes[1],t),4&o&&this[s](e.nodes[2],t),8&o&&this[s](e.nodes[3],t)}insertAsGrid(e,t){!0===this.inside(e.bound,t)?(!0!==e.covered&&(this.merge(e),e.taken=!0,e.covered=!0),e.rects.push(t),this._timesCovered.push(performance.now(),e.bound,e.level)):(e.rects.push(t),e.nodes.length?(this.insertBatch(e,t,"insertAsGrid"),e.rects.splice(0)):!0!==e.covered&&e.level<this.cellDepthMax&&(this.split(e),e.rects.forEach((t=>{this.insertBatch(e,t,"insertAsGrid")})),e.rects.splice(0)),0===e.nodes.length&&e.rects.length>0?e.taken=!0:delete e.taken,this._times.push(performance.now(),e.bound,e.level))}insertAsTree(e,t){e.nodes.length?this.insertBatch(e,t,"insertAsTree"):(e.rects.push(t),e.rects.length>this.cellItemsMax&&e.level<this.cellDepthMax&&(e.nodes.length||this.split(e),e.rects.forEach((t=>this.insertBatch(e,t,"insertAsTree"))),e.rects.splice(0)))}allNodes(e,t){return t.nodes.length>0?t.nodes.forEach((t=>{this.allNodes(e,t)})):e.push(t),e}allRects(e,t){return t.nodes.length>0?t.nodes.forEach((t=>{this.allRects(e,t)})):e.push(...t.rects),e}retrieve(e,t,s){const o=this.getIndex(e,t),n=s||[];if(e.nodes.length&&(1&o&&this.retrieve(e.nodes[0],t,n),2&o&&this.retrieve(e.nodes[1],t,n),4&o&&this.retrieve(e.nodes[2],t,n),8&o&&this.retrieve(e.nodes[3],t,n)),!s)return new Set(n);0===e.nodes.length&&s.push(...e.rects)}clear(){this.root.nodes.splice(0),this.root.rects.splice(0),delete this.root.taken,delete this.root.covered}}(t,s,o,2),i=[0,0,20,20],c={activeRects:new Set,activeNodes:[],rects:[]},l=document.getElementById("canvas");l.setAttribute("width","1200"),l.setAttribute("height","1000"),l.style.background="#111";const h=l.getContext("2d");let d=!1;function a(e){e.nodes.length?e.nodes.forEach((e=>a(e))):e.taken||(h.strokeStyle="rgba(0, 255, 0, 0.4)",h.strokeRect(...g(e.bound)))}function u(e){e.nodes.length?e.nodes.forEach((e=>u(e))):e.taken&&(h.fillStyle="rgba(255,255,255, 0.8)",h.fillRect(...g(e.bound)))}function f(e){e.nodes.length?e.nodes.forEach((e=>f(e))):e.taken&&(h.strokeStyle="rgba(6, 6, 6, 0.8)",h.strokeRect(...g(e.bound)))}function g(e){return[e[0]-e[2],e[1]-e[3],2*e[2],2*e[3]]}l.addEventListener("mousemove",(function(e){d=!0,e.offsetX||(e.offsetX=e.layerX-e.target.offsetLeft,e.offsetY=e.layerY-e.target.offsetTop),i[0]=e.offsetX,i[1]=e.offsetY})),l.addEventListener("mouseout",(function(e){d=!1})),function e(){var o;d&&(c.activeRects.clear(),c.activeRects=r.retrieve(r.root,i)),h.clearRect(0,0,t,s),document.getElementById("info_count").innerText=c.rects.length+"",document.getElementById("info_involved").innerText=((null===(o=c.activeRects)||void 0===o?void 0:o.size)||0)+"",d&&(h.fillStyle="rgba(255,255,255,0.5)",h.fillRect(...g(i))),a(r.root),u(r.root),f(r.root),c.rects.forEach((e=>{c.activeRects.has(e)?(h.fillStyle="rgba(0, 255, 0, 0.5)",h.fillRect(...g(e))):(h.strokeStyle="rgba(255, 0, 0, 1)",h.strokeRect(...g(e)))})),window.requestAnimationFrame(e)}(),window.addNodes=function(e,t=!1){const s=Math.ceil(Math.sqrt(e)),o=Array(s).fill(null);o.forEach(((s,n)=>{o.forEach(((s,o)=>{const r=2*(t||e>=10&&n<.1*e?30:1)/2,i=2*(t||e>=10&&o<.1*e?30:1)/2;c.rects.push([3*r*n*1.1+r,3*i*o*1.1+i,r,i])}))}));const n=performance.now();for(let e=0;e<c.rects.length;e++)r.insertAsGrid(r.root,c.rects[e]);const i=performance.now();console.log(`add ${e} duration`,i-n),console.log("allNodes",r.allNodes([],r.root)),console.log("times",r._times.length/3,r._times),console.log("timesCovered",r._timesCovered.length/3,r._timesCovered)}})();
//# sourceMappingURL=demo.bundle.js.map